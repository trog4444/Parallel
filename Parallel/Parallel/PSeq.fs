namespace Rogz.Parallel

open System.Linq

/// <summary>Result of a parallel query.</summary>
type 'T pseq = ParallelQuery<'T>


/// <summary>Sequence operations using parallelism based on the Linq library.
///
/// Note: results may not always return in the same order as in the original sequence(s) and
/// may run slower than their non-parallel counterpart. Testing should be used to determine
/// the optimal module to use on a case-by-case basis.</summary>
module PSeq =    

    /// <summary>Converst a seq<'T> to a pseq<'T>.</summary>
    [<System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)>]
    let inline toPSeq (source: ^T seq) : ^T pseq =
        match source with
        | null -> ParallelEnumerable.Empty< ^T>()
        | :? pseq< ^T> as p -> p
        | _ -> source.AsParallel()


    /// <summary>Methods of modifying the parallelism characteristics of a query.</summary>
    module PSeqOption =

        /// <summary>Enables treatment of a data source as if it were ordered, overriding the default of unordered.</summary>
        let inline asOrdered source : ^T pseq = 
            (toPSeq source).AsOrdered()

        /// <summary>Sets the CancellationToken to associate with the query.</summary>
        let inline withCancellation cancellationToken source : ^T pseq = 
            (toPSeq source).WithCancellation(cancellationToken)

        /// <summary>Sets the degree of parallelism to use in a query. Degree of parallelism is the maximum
        /// number of concurrently executing tasks that will be used to process the query.</summary>
        ///
        /// The degree of parallelism must be within 1 and 511. If the value provided is outside of that
        /// range then a default value will be used.</summary>
        let inline withDegree degree source : ^T pseq =
            (toPSeq source).WithDegreeOfParallelism((min 511 (max 1 degree)))

        /// <summary>Sets the execution mode of the query.</summary>
        let inline withExecMode executionMode source : ^T pseq = 
            (toPSeq source).WithExecutionMode(executionMode)

        /// <summary>Sets the merge options for this query, which specify how the query will buffer output.</summary>
        let inline withMergeOptions mergeOptions source : ^T pseq =
            (toPSeq source).WithMergeOptions(mergeOptions)


    /// <summary>Wraps the two given enumerations as a single concatenated enumeration.</summary>
    let inline append xs ys : ^T pseq = (toPSeq xs).Concat(toPSeq ys)

    /// <summary>Returns the average of the elements in the sequence.</summary>
    [<Sealed; AbstractClass>]
    type average =
        static member inline Decimals (source: decimal seq) = (toPSeq source).Average()
        static member inline Floats (source: float seq) = (toPSeq source).Average()
        static member inline Float32s (source: float32 seq) = (toPSeq source).Average()
        static member inline Ints (source: int seq) = (toPSeq source).Average()       
        static member inline Int64s (source: int64 seq) = (toPSeq source).Average()
        
    /// <summary>Returns the average of the results generated by applying the function to each element of the sequence.</summary>
    [<Sealed; AbstractClass>]
    type averageBy =
        static member inline Decimals (f: ^a -> decimal, source) = (toPSeq source).Average(f)
        static member inline Floats (f: ^a -> float, source) = (toPSeq source).Average(f)
        static member inline Float32s (f: ^a -> float32, source) = (toPSeq source).Average(f)
        static member inline Ints (f: ^a -> int, source) = (toPSeq source).Average(f)
        static member inline Int64s (f: ^a -> int64, source) = (toPSeq source).Average(f)

    /// <summary>Returns a sequence that corresponds to a cached version of the input sequence.</summary>
    let inline cache (source: ^T seq) : ^T pseq =
        match source with
        | null -> ParallelEnumerable.Empty<_>()
        | _    -> Seq.cache(source).AsParallel()

    /// <summary>Applies the given function to each element of the sequence.
    /// Return the sequence comprised of the results for each element where the function returns Some.</summary>
    let inline choose (chooser: ^T -> ^U option) source : ^U pseq = 
        (toPSeq source)
            .Select(chooser)
            .Where(Option.isSome)
            .Select(Option.get)

    /// <summary>Projects each element of a sequence to a new sequence, flattens the resulting sequences into one sequence.</summary>
    let inline collect (projection: ^T -> ^U seq) source : ^U pseq =
        (toPSeq source).SelectMany(fun a -> match projection a with null -> Seq.empty | b -> b)

    /// <summary>Projects each element of a sequence to a new sequence, flattens the resulting sequences
    /// into one sequence, and applies a mapping to each element therein.</summary>
    let inline collectMap (projection: ^T -> ^U seq) (mapping: ^T -> ^U -> ^V) source : ^V pseq =
        let inline nx xs = match xs with null -> Seq.empty | _ -> xs
        (toPSeq source).SelectMany(projection >> nx, mapping)    

    /// <summary>Combines the given enumeration-of-enumerations as a single concatenated enumeration.</summary>
    let inline concat source : ^T pseq =
        (toPSeq source).SelectMany(fun a -> match a with null -> Seq.empty | _ -> a)

    /// <summary>Evaluates to true if the given element is in the input sequence.</summary>
    let inline contains elem (source: ^T seq) : bool =
        (toPSeq source).Any((=) elem)

    /// <summary>Applies a key-generating function to each element of a sequence and return a sequence
    /// yielding unique keys and their number of occurrences in the original sequence.</summary>
    let inline countBy (f: ^T -> ^Key) source : (^Key * int) pseq = 
        (toPSeq source).GroupBy(f).Select(fun kvs -> kvs.Key, kvs.Count())

    /// <summary>Returns a sequence that is built from the given delayed specification of a sequence.</summary>
    let inline delay generator : ^T pseq = toPSeq (generator ())

    /// <summary>Returns a sequence that contains no duplicate entries according to generic hash and
    /// equality comparisons on the entries. If an element occurs multiple times in the sequence
    /// then the later occurrences are discarded.</summary>
    let inline distinct source : ^T pseq =
        (toPSeq source).Distinct(HashIdentity.Structural)    

    /// <summary>Returns a sequence that contains no duplicate entries according to the generic hash and
    /// equality comparisons on the keys returned by the given key-generating function.
    /// If an element occurs multiple times in the sequence then the later occurrences are discarded.</summary>
    let inline distinctBy (projection: ^T -> ^Key) source : ^T pseq = 
        let comparer = 
            { new System.Collections.Generic.IEqualityComparer< ^T * ^Key> with
                member __.Equals((_, p1), (_, p2)) = p1 = p2
                member __.GetHashCode((_, p1)) = p1.GetHashCode() }
        (toPSeq source)
            .Select(fun x -> x, projection x)
            .Distinct(comparer)
            .Select(fst)

    /// <summary>Create an empty sequence.</summary>
    let empty<'T> : ^T pseq = ParallelEnumerable.Empty< ^T>()

    /// <summary>Tests if any element of the sequence satisfies the given predicate.</summary>
    let inline exists (predicate: ^T -> bool) source = 
        (toPSeq source).Any(predicate)

    /// <summary>Tests if any pair of elements of the input sequences satisfies the given predicate.</summary>
    let inline exists2 (predicate: ^T -> ^U -> bool) (source1: ^T seq) (source2: ^U seq) : bool = 
        (toPSeq source1).Zip(toPSeq source2, predicate).Any(id)

    /// <summary>Returns a new collection containing only the elements of the collection for which
    /// the given predicate returns true.</summary>
    let inline filter (predicate: ^T -> bool) source : ^T pseq =
        (toPSeq source).Where predicate

    /// <summary>Applies a function to each element of the collection, threading an accumulator argument
    /// through the computation. If the input function is f and the elements are i0...iN, then
    /// this function computes f (... (f s i0)...) iN.</summary>
    let inline fold (folder: ^State -> ^T -> ^State) (state: ^State) (source: ^T seq) : ^State =
        (toPSeq source).Aggregate(state, folder)

    /// <summary>Tests if all elements of the sequence satisfy the given predicate.</summary>
    let inline forall (predicate: ^T -> bool) source = 
        (toPSeq source).All(predicate)

    /// <summary>Tests the all pairs of elements drawn from the two sequences satisfy the given predicate.
    /// If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.</summary>
    let inline forall2 (predicate: ^T -> ^U -> bool) (source1: ^T seq) (source2: ^U seq) : bool = 
        (toPSeq source1).Zip(toPSeq source2, predicate).All(id)

    /// <summary>Applies a key-generating function to each element of a sequence and yields a sequence of
    /// unique keys. Each unique key has also contains a sequence of all elements that match to this key.</summary>
    let inline groupBy (projection: ^T -> ^Key) source : (^Key * ^T seq) pseq =
        (toPSeq source).GroupBy(projection, fun k v -> k, (match v with null -> Seq.empty | _ -> v))

    /// <summary>Correlates the elements in two sequences based on matching keys. The default equality comparer is used.</summary>
    let inline join (outerSelector: ^T -> ^Key) (innerSelector: ^U -> ^Key) (resultSelector: ^T -> ^U -> ^V)
        inner outer : ^V pseq =
            (toPSeq outer).Join(toPSeq inner, outerSelector, innerSelector, resultSelector)

    /// <summary>Generates a new sequence which, when iterated, returns successive elements by calling the given
    /// function, up to the given count. The results of calling the function are not saved, that is,
    /// the function is reapplied as necessary to regenerate the elements.
    /// The function is passed the index of the item being generated.</summary>
    let inline init count (initializer: int -> ^T) : ^T pseq =
        ParallelEnumerable.Range(0, max 0 count).Select(initializer)

    /// <summary>Tests whether a sequence has any elements.</summary>
    let inline isEmpty (source: ^T pseq) : bool =
        isNull source || Seq.isEmpty source

    /// <summary>Applies the given function to each element of the collection.</summary>
    let inline iter (action: ^T -> unit) (source: ^T seq) : unit =
        (toPSeq source).ForAll(fun a -> action a)

    /// <summary>Applies the given function to two collections simultaneously.
    /// If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.</summary>
    let inline iter2 (action: ^T -> ^U -> unit) (source1: ^T seq) (source2: ^U seq) : unit =
        ignore ((toPSeq source1).Zip(toPSeq source2, action))

    /// <summary>Applies the given function to each element of the collection.
    /// The integer passed to the function indicates the index of element.</summary>
    let inline iteri (action: int -> ^T -> unit) (source: ^T seq) : unit =
        ignore ((toPSeq source).Select(fun t i -> action i t))

    /// <summary>Returns the length of the sequence.</summary>
    let inline length (source: ^T seq) = (toPSeq source).Count()

    /// <summary>Creates a new collection whose elements are the results of applying the given function
    /// to each of the elements of the collection. The given function will be applied as 
    /// elements are demanded using the MoveNext method on enumerators retrieved from the object.</summary>
    let inline map (mapping: ^T -> ^U) (source: ^T seq) : ^U pseq =
        (toPSeq source).Select(mapping)

    /// <summary>Creates a new collection whose elements are the results of applying the given function to
    /// the corresponding pairs of elements from the two sequences. If one input sequence is
    /// shorter than the other then the remaining elements of the longer sequence are ignored.</summary>
    let inline map2 (mapping: ^T -> ^U -> ^V) (source1: ^T seq) (source2: ^U seq) : ^V pseq =
        (toPSeq source1).Zip(toPSeq source2, mapping)

    /// <summary>Creates a new collection whose elements are the results of applying the given function to
    /// each of the elements of the collection. The integer index passed to the function indicates
    /// the index (from 0) of element being transformed.</summary>
    let inline mapi (mapping: int -> ^T -> ^U) (source: ^T seq) : ^U pseq =
        (toPSeq source).Select(fun t i -> mapping i t)

    /// <summary>Views the given array as a sequence.</summary>
    let inline ofArray (source: ^T []) : ^T pseq = toPSeq source

    /// <summary>Views the given list as a sequence.</summary>
    let inline ofList (source: ^T list) : ^T pseq = toPSeq source

    /// <summary>Creates a new sequence object that delegates to the given sequence object.
    /// This ensures the original sequence cannot be rediscovered and mutated by a type cast.
    /// For example, if given an array the returned sequence will return the elements of the array,
    /// but you cannot cast the returned sequence object to an array.</summary>
    let inline readonly (source: ^T seq) : ^T pseq =
        if isNull source then empty else toPSeq (Seq.readonly source)

    /// <summary>Returns a sequence that yields one item only.</summary>
    let inline singleton value : ^T pseq = [|value|].AsParallel()

    /// <summary>Returns a sequence that skips a specified number of elements of the underlying
    /// sequence and then yields the remaining elements of the sequence.</summary>
    let inline skip count source : ^T pseq = 
        (toPSeq source).Skip(max 0 count)

    /// <summary>Returns a sequence that, when iterated, skips elements of the underlying sequence
    /// while the given predicate returns true, and then yields the remaining elements of the sequence.</summary>
    let inline skipWhile (predicate: ^T -> bool) source : ^T pseq = 
        (toPSeq source).SkipWhile(predicate)

    /// <summary>Yields a sequence ordered by keys.</summary>
    let inline sort source : ^T pseq when ^T : comparison = 
        (toPSeq source).OrderBy(id, ComparisonIdentity.Structural) :> ^T pseq

    /// <summary>Applies a key-generating function to each element of a sequence and yield a sequence ordered by keys.
    /// The keys are compared using generic comparison as implemented by Operators.compare.</summary>
    let inline sortBy (projection: ^T -> ^Key when ^Key : comparison) source : ^T pseq = 
        (toPSeq source).OrderBy(projection, ComparisonIdentity.Structural) :> ^T pseq

    /// <summary>Applies a key-generating function to each element of a sequence and yield a sequence ordered by keys.
    /// The keys are compared, descending, using generic comparison as implemented by Operators.compare.</summary>
    let inline sortByDescending (sorter: ^T -> ^Key) (source: ^T seq) : ^T pseq =
        (toPSeq source).OrderByDescending(sorter, ComparisonIdentity.Structural) :> ^T pseq

    /// <summary>Returns the sum of the elements in the sequence.</summary>
    [<Sealed; AbstractClass>]
    type sum =
        static member inline Decimals (source: decimal seq) = (toPSeq source).Sum()
        static member inline Floats (source: float seq) = (toPSeq source).Sum()
        static member inline Float32s (source: float32 seq) = (toPSeq source).Sum()
        static member inline Ints (source: int seq) = (toPSeq source).Sum()
        static member inline Int64s (source: int64 seq) = (toPSeq source).Sum()
        
    /// <summary>Returns the sum of the results generated by applying the function to each element of the sequence.</summary>
    [<Sealed; AbstractClass>]
    type sumBy =
        static member inline Decimals (f: ^T -> decimal, source) = (toPSeq source).Sum(f)
        static member inline Floats (f: ^T -> float, source) = (toPSeq source).Sum(f)
        static member inline Float32s (f: ^T -> float32, source) = (toPSeq source).Sum(f)
        static member inline Ints (f: ^T -> int, source) = (toPSeq source).Sum(f)
        static member inline Int64s (f: ^T -> int64, source) = (toPSeq source).Sum(f)

    /// <summary>Returns a new sequence by taking the input sequence without its first element.</summary>
    let inline tail (source: ^T seq) : ^T pseq =
        if isNull source || Seq.isEmpty source then empty else toPSeq (Seq.tail source)

    /// <summary>Returns a sequence that when enumerated returns no more than a specified number of elements.</summary>
    let inline take count (source: ^T seq) : ^T pseq =
        (toPSeq source).Take(max 0 count)

    /// <summary>Returns a sequence that, when iterated, yields elements of the underlying sequence while
    /// the given predicate returns true, and then returns no further elements.</summary>
    let inline takeWhile (predicate: ^T -> bool) (source: ^T seq) : ^T pseq =
        (toPSeq source).TakeWhile(predicate)

    /// <summary>Creates an array from the given collection.</summary>
    let inline toArray (source: ^T pseq) : ^T [] =
        if isNull source then Array.empty else source.ToArray()

    /// <summary>Creates a list from the given collection.</summary>
    let inline toList (source: ^T pseq) : ^T list =
        if isNull source then List.empty else Seq.toList source

    /// <summary>Creates a sequentially-evaluated collection from the given parallel collection.</summary>
    let inline toSeq (source: ^T pseq) : ^T seq =
        match source with null -> Seq.empty | _ -> source.AsSequential()    

    /// <summary>Returns the first element for which the given function returns true, or None if no such element exists.</summary>
    let inline tryFind (predicate: ^T -> bool) source : ^T option = 
        (toPSeq source).Where(predicate).Select(Some).FirstOrDefault()

    /// <summary>Returns the index of the first element in the sequence that satisfies the given predicate,
    /// or None if no such element exists.</summary>
    let inline tryFindIndex (predicate: ^T -> bool) (source: ^T seq) : int option =
        (toPSeq source)
            .Select(fun t i -> i, predicate t)
            .Where(fun (_, b) -> b)
            .Select(fun (v, _) -> Some v)
            .FirstOrDefault()

    /// <summary>Returns the first element of the sequence, or None otherwise.</summary>
    let inline tryHead (source: ^T pseq) : ^T option =
        (toPSeq source).Select(Some).FirstOrDefault()

    /// <summary>Returns the first element of the sequence, or None otherwise.</summary>
    let inline tryLast (source: ^T pseq) : ^T option =
        Seq.tryLast source

    /// <summary>Returns the greatest of all elements of the sequence, compared by using Operators.max.</summary>
    let inline tryMax (source: ^T seq) : ^T option =    
        if isNull source || Seq.isEmpty source then None else Some ((toPSeq source).Max())
    
    /// <summary>Returns the greatest of all elements of the sequence, compared by using Operators.max on
    /// the function result.</summary>
    let inline tryMaxBy (projection : ^T -> ^U when ^U : comparison) (source : seq< ^T>) : ^T option = 
        if isNull source || Seq.isEmpty source then None
        else Some (match (toPSeq source)
                    .Select(fun x -> struct (projection x, x))
                    .Aggregate(fun (struct (minVal, minElem)) (struct (curVal, curElem)) ->
                        if curVal > minVal then (struct (curVal, curElem))
                        else (struct (minVal, minElem))) with struct (_, elem) -> elem)
    
    /// <summary>Returns the lowest of all elements of the sequence, compared by using Operators.min.</summary>
    let inline tryMin (source: ^T seq) : ^T option =
        if isNull source || Seq.isEmpty source then None else Some ((toPSeq source).Min())
    
    /// <summary>Returns the lowest of all elements of the sequence, compared by using Operators.min on
    /// the function result.</summary>
    let inline tryMinBy (projection: ^T -> ^U when ^U : comparison) (source: ^T seq) = 
        if isNull source || Seq.isEmpty source then None
        else Some (match (toPSeq source)
                    .Select(fun x -> struct (projection x, x))
                    .Aggregate(fun (struct (minVal, minElem)) (struct (curVal, curElem)) ->
                        if curVal < minVal
                        then struct (curVal, curElem)
                        else struct (minVal, minElem)) with struct (_, elem) -> elem)

    /// <summary>Returns the nth element of the sequence, or None if the element doesn't have 'n' or more members.</summary>
    let inline tryNth n source : ^T option =
        (toPSeq source).Skip(max 0 n).Select(Some).FirstOrDefault()

    /// <summary>Applies the given function to successive elements, returning the first value where the
    /// function returns a Some value.</summary>
    let inline tryPick (chooser: ^T -> ^U option) (source: ^T seq) : ^U option =
        (toPSeq source)
            .Select(chooser)
            .Where(Option.isSome)
            .FirstOrDefault()

    /// <summary>Returns a new collection containing only the elements of the collection for which the
    /// given predicate returns true. A synonym for PSeq.filter.</summary>
    let inline where (predicate: ^T -> bool) source : ^T pseq = filter predicate source

    /// <summary>Combines the two sequences into a list of pairs. The two sequences need not have
    /// equal lengths: when one sequence is exhausted any remaining elements in the other sequence are ignored.</summary>
    let inline zip (source1: ^T seq) (source2: ^U seq) : (^T * ^U) pseq =
        (toPSeq source1).Zip(toPSeq source2, fun a b -> a, b)