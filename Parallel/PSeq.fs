namespace Parallel

(*
chunkBySize
compareWith
pairwise
scan
unfold
windowed
*)


/// Sequence operations using parallelism based on the Linq library.
///
/// Note: results may not always return in the same order as in the original sequence(s) and
/// may run slower than their non-parallel counterpart. Testing should be used to determin
/// the optimal module to use on a case-by-case basis.
module PSeq =

    open System.Linq


    /// Result of a parallel query.
    type 'a pseq = ParallelQuery<'a>


    /// Converst a seq<'T> to a pseq<'T>.
    let inline toPSeq (source: ^T seq) : ^T pseq = 
        match source with
        | null -> ParallelEnumerable.Empty< ^T>()
        | :? pseq< ^T> as p -> p
        | _ -> source.AsParallel()


    /// Methods of modifying the parallelism characteristics of a query.
    module ParallelOption =

        /// Enables treatment of a data source as if it were ordered, overriding the default of unordered.
        let inline asOrdered source : ^T pseq = 
            (toPSeq source).AsOrdered()

        /// Sets the CancellationToken to associate with the query.
        let inline withCancellation cancellationToken source : ^T pseq = 
            (toPSeq source).WithCancellation(cancellationToken)

        /// Sets the degree of parallelism to use in a query. Degree of parallelism is the maximum
        /// number of concurrently executing tasks that will be used to process the query.
        ///
        /// The degree of parallelism must be within 1 and 511. If the value provided is outside of that
        /// range then a default value will be used.
        let inline withDegree (degree: uint32) source : ^T pseq =
            (toPSeq source).WithDegreeOfParallelism(int (min 511u (max 1u degree)))

        /// Sets the execution mode of the query.
        let inline withExecMode executionMode source : ^T pseq = 
            (toPSeq source).WithExecutionMode(executionMode)

        /// Sets the merge options for this query, which specify how the query will buffer output.
        let inline withMergeOptions mergeOptions source : ^T pseq =
            (toPSeq source).WithMergeOptions(mergeOptions)


    /// Wraps the two given enumerations as a single concatenated enumeration.
    let inline append xs ys : ^a pseq = (toPSeq xs).Concat(toPSeq ys)

    /// Returns the average of the elements in the sequence.
    type average =        
        static member inline Decimals (source: decimal seq) = (toPSeq source).Average()
        static member inline Floats (source: float seq) = (toPSeq source).Average()
        static member inline Float32s (source: float32 seq) = (toPSeq source).Average()
        static member inline Ints (source: int seq) = (toPSeq source).Average()       
        static member inline Int64s (source: int64 seq) = (toPSeq source).Average()
        
    /// Returns the average of the results generated by applying the function to each element of the sequence.
    type averageBy =
        static member inline Decimals (f: ^a -> decimal, source) = (toPSeq source).Average(f)
        static member inline Floats (f: ^a -> float, source) = (toPSeq source).Average(f)
        static member inline Float32s (f: ^a -> float32, source) = (toPSeq source).Average(f)
        static member inline Ints (f: ^a -> int, source) = (toPSeq source).Average(f)
        static member inline Int64s (f: ^a -> int64, source) = (toPSeq source).Average(f)

    /// Returns a sequence that corresponds to a cached version of the input sequence.
    let inline cache (source: ^T seq) : ^T pseq =
        match source with
        | null -> ParallelEnumerable.Empty<_>()
        | _    -> Seq.cache(source).AsParallel()

    /// Applies the given function to each element of the sequence.
    /// Return the sequence comprised of the results for each element where the function returns Some.
    let inline choose (chooser: ^T -> ^U option) source : ^U pseq = 
        (toPSeq source)
            .Select(chooser)
            .Where(Option.isSome)
            .Select(Option.get)

    /// Projects each element of a sequence to a new sequence, flattens the resulting sequences into one sequence.
    let inline collect (projection: ^T -> ^U seq) source : ^U pseq =
        (toPSeq source).SelectMany(fun a -> match projection a with null -> Seq.empty | b -> b)

    /// Projects each element of a sequence to a new sequence, flattens the resulting sequences
    /// into one sequence, and applies a mapping to each element therein.
    let inline collectMap (projection: ^T -> ^U seq) (mapping: ^T -> ^U -> ^V) source : ^V pseq =
        let inline nx xs = match xs with null -> Seq.empty | _ -> xs
        (toPSeq source).SelectMany(projection >> nx, mapping)    

    /// Combines the given enumeration-of-enumerations as a single concatenated enumeration.
    let inline concat source : ^T pseq =
        (toPSeq source).SelectMany(fun a -> match a with null -> Seq.empty | _ -> a)

    /// Evaluates to true if the given element is in the input sequence.
    let inline contains elem (source: ^T seq) : bool =
        (toPSeq source).Any((=) elem)

    /// Applies a key-generating function to each element of a sequence and return a sequence
    /// yielding unique keys and their number of occurrences in the original sequence.
    let inline countBy (f: ^T -> ^Key) source : (^Key * int) pseq = 
        (toPSeq source).GroupBy(f).Select(fun kvs -> kvs.Key, kvs.Count())

    /// Returns a sequence that is built from the given delayed specification of a sequence.
    let inline delay generator : ^T pseq = toPSeq (generator ())

    /// Returns a sequence that contains no duplicate entries according to generic hash and
    /// equality comparisons on the entries. If an element occurs multiple times in the sequence
    /// then the later occurrences are discarded.
    let inline distinct source : ^T pseq =
        (toPSeq source).Distinct(HashIdentity.Structural)    

    /// Returns a sequence that contains no duplicate entries according to the generic hash and
    /// equality comparisons on the keys returned by the given key-generating function.
    /// If an element occurs multiple times in the sequence then the later occurrences are discarded.
    let inline distinctBy (projection: ^T -> ^Key) source : ^T pseq = 
        let comparer = 
            { new System.Collections.Generic.IEqualityComparer< ^T * ^Key> with
                member __.Equals((_, p1), (_, p2)) = p1 = p2
                member __.GetHashCode((_, p1)) = p1.GetHashCode() }
        (toPSeq source)
            .Select(fun x -> x, projection x)
            .Distinct(comparer)
            .Select(fst)

    /// Create an empty sequence.
    let inline empty<'T> : ^T pseq = ParallelEnumerable.Empty< ^T>()

    /// Tests if any element of the sequence satisfies the given predicate.
    let inline exists (predicate: ^T -> bool) source = 
        (toPSeq source).Any(predicate)

    /// Tests if any pair of elements of the input sequences satisfies the given predicate.
    let inline exists2 (predicate: ^T -> ^U -> bool) (source1: ^T seq) (source2: ^U seq) : bool = 
        (toPSeq source1).Zip(toPSeq source2, predicate).Any(id)

    /// Returns a new collection containing only the elements of the collection for which
    /// the given predicate returns true.
    let inline filter (predicate: ^T -> bool) source : ^T pseq =
        (toPSeq source).Where predicate

    /// Applies a function to each element of the collection, threading an accumulator argument
    /// through the computation. If the input function is f and the elements are i0...iN, then
    /// this function computes f (... (f s i0)...) iN.
    let inline fold (folder: ^State -> ^T -> ^State) (state: ^State) (source: ^T seq) : ^State =
        (toPSeq source).Aggregate(state, folder)

    /// Tests if all elements of the sequence satisfy the given predicate.
    let inline forall (predicate: ^T -> bool) source = 
        (toPSeq source).All(predicate)

    /// Tests the all pairs of elements drawn from the two sequences satisfy the given predicate.
    /// If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.
    let inline forall2 (predicate: ^T -> ^U -> bool) (source1: ^T seq) (source2: ^U seq) : bool = 
        (toPSeq source1).Zip(toPSeq source2, predicate).All(id)

    /// Applies a key-generating function to each element of a sequence and yields a sequence of
    /// unique keys. Each unique key has also contains a sequence of all elements that match to this key.
    let inline groupBy (projection: ^T -> ^Key) source : (^Key * ^T seq) pseq =
        (toPSeq source).GroupBy(projection, fun k v -> k, (match v with null -> Seq.empty | _ -> v))

    /// Generates a new sequence which, when iterated, returns successive elements by calling the given
    /// function, up to the given count. The results of calling the function are not saved, that is,
    /// the function is reapplied as necessary to regenerate the elements.
    /// The function is passed the index of the item being generated.
    let inline init (count: uint32) (initializer: int -> ^T) : ^T pseq =
        ParallelEnumerable.Range(0, int count).Select(initializer)

    /// Tests whether a sequence has any elements.
    let inline isEmpty (source: ^T pseq) : bool =
        isNull source || Seq.isEmpty source

    /// Applies the given function to each element of the collection.
    let inline iter (action: ^T -> unit) (source: ^T seq) : unit =
        (toPSeq source).ForAll(fun a -> action a)

    /// Applies the given function to two collections simultaneously.
    /// If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.
    let inline iter2 (action: ^T -> ^U -> unit) (source1: ^T seq) (source2: ^U seq) : unit =
        ignore ((toPSeq source1).Zip(toPSeq source2, action))

    /// Applies the given function to each element of the collection.
    /// The integer passed to the function indicates the index of element.
    let inline iteri (action: int -> ^T -> unit) (source: ^T seq) : unit =
        ignore ((toPSeq source).Select(fun t i -> action i t))

    /// Returns the length of the sequence.
    let inline length (source: ^T seq) = (toPSeq source).Count()

    /// Creates a new collection whose elements are the results of applying the given function
    /// to each of the elements of the collection. The given function will be applied as 
    /// elements are demanded using the MoveNext method on enumerators retrieved from the object.
    let inline map (mapping: ^T -> ^U) (source: ^T seq) : ^U pseq =
        (toPSeq source).Select(mapping)

    /// Creates a new collection whose elements are the results of applying the given function to
    /// the corresponding pairs of elements from the two sequences. If one input sequence is
    /// shorter than the other then the remaining elements of the longer sequence are ignored.
    let inline map2 (mapping: ^T -> ^U -> ^V) (source1: ^T seq) (source2: ^U seq) : ^V pseq =
        (toPSeq source1).Zip(toPSeq source2, mapping)

    /// Creates a new collection whose elements are the results of applying the given function to
    /// each of the elements of the collection. The integer index passed to the function indicates
    /// the index (from 0) of element being transformed.
    let inline mapi (mapping: int -> ^T -> ^U) (source: ^T seq) : ^U pseq =
        (toPSeq source).Select(fun t i -> mapping i t)

    /// Views the given array as a sequence.
    let inline ofArray (source: ^T []) : ^T pseq = toPSeq source

    /// Views the given list as a sequence.
    let inline ofList (source: ^T list) : ^T pseq = toPSeq source

    /// Creates a new sequence object that delegates to the given sequence object.
    /// This ensures the original sequence cannot be rediscovered and mutated by a type cast.
    /// For example, if given an array the returned sequence will return the elements of the array,
    /// but you cannot cast the returned sequence object to an array.
    let inline readonly (source: ^T seq) : ^T pseq =
        if isNull source then empty else toPSeq (Seq.readonly source)

    /// Returns a sequence that yields one item only.
    let inline singleton value : ^T pseq = [|value|].AsParallel()

    /// Returns a sequence that skips a specified number of elements of the underlying
    /// sequence and then yields the remaining elements of the sequence.
    let inline skip (count: uint32) source : ^T pseq = 
        (toPSeq source).Skip(int count)

    /// Returns a sequence that, when iterated, skips elements of the underlying sequence
    /// while the given predicate returns true, and then yields the remaining elements of the sequence.
    let inline skipWhile (predicate: ^T -> bool) source : ^T pseq = 
        (toPSeq source).SkipWhile(predicate)

    /// Yields a sequence ordered by keys.
    let inline sort source : ^T pseq when ^T : comparison = 
        (toPSeq source).OrderBy(id, ComparisonIdentity.Structural) :> ^T pseq

    /// Applies a key-generating function to each element of a sequence and yield a sequence ordered by keys.
    /// The keys are compared using generic comparison as implemented by Operators.compare.
    let inline sortBy (projection: ^T -> ^Key when ^Key : comparison) source : ^T pseq = 
        (toPSeq source).OrderBy(projection, ComparisonIdentity.Structural) :> ^T pseq

    /// Applies a key-generating function to each element of a sequence and yield a sequence ordered by keys.
    /// The keys are compared, descending, using generic comparison as implemented by Operators.compare.
    let inline sortByDescending (sorter: ^T -> ^Key) (source: ^T seq) : ^T pseq =
        (toPSeq source).OrderByDescending(sorter, ComparisonIdentity.Structural) :> ^T pseq

    /// Returns the sum of the elements in the sequence.
    type sum =        
        static member inline Decimals (source: decimal seq) = (toPSeq source).Sum()
        static member inline Floats (source: float seq) = (toPSeq source).Sum()
        static member inline Float32s (source: float32 seq) = (toPSeq source).Sum()
        static member inline Ints (source: int seq) = (toPSeq source).Sum()
        static member inline Int64s (source: int64 seq) = (toPSeq source).Sum()
        
    /// Returns the sum of the results generated by applying the function to each element of the sequence.
    type sumBy =
        static member inline Decimals (f: ^T -> decimal, source) = (toPSeq source).Sum(f)
        static member inline Floats (f: ^T -> float, source) = (toPSeq source).Sum(f)
        static member inline Float32s (f: ^T -> float32, source) = (toPSeq source).Sum(f)
        static member inline Ints (f: ^T -> int, source) = (toPSeq source).Sum(f)
        static member inline Int64s (f: ^T -> int64, source) = (toPSeq source).Sum(f)

    /// Returns a new sequence by taking the input sequence without its first element.
    let inline tail (source: ^T seq) : ^T pseq =
        if isNull source || Seq.isEmpty source then empty else toPSeq (Seq.tail source)

    /// Returns a sequence that when enumerated returns no more than a specified number of elements.
    let inline take (count: uint32) (source: ^T seq) : ^T pseq =
        (toPSeq source).Take(int count)

    /// Returns a sequence that, when iterated, yields elements of the underlying sequence while
    /// the given predicate returns true, and then returns no further elements.
    let inline takeWhile (predicate: ^T -> bool) (source: ^T seq) : ^T pseq =
        (toPSeq source).TakeWhile(predicate)

    /// Creates an array from the given collection.
    let inline toArray (source: ^T pseq) : ^T [] =
        if isNull source then Array.empty else source.ToArray()

    /// Creates a list from the given collection.
    let inline toList (source: ^T pseq) : ^T list =
        if isNull source then List.empty else Seq.toList source

    /// Creates a sequentially-evaluated collection from the given parallel collection.
    let inline toSeq (source: ^T pseq) : ^T seq =
        match source with null -> Seq.empty | _ -> source.AsSequential()    

    /// Returns the first element for which the given function returns true, or None if no such element exists.
    let inline tryFind (predicate: ^T -> bool) source : ^T option = 
        (toPSeq source).Where(predicate).Select(Some).FirstOrDefault()

    /// Returns the index of the first element in the sequence that satisfies the given predicate,
    /// or None if no such element exists.
    let inline tryFindIndex (predicate: ^T -> bool) (source: ^T seq) : int option =
        (toPSeq source)
            .Select(fun t i -> i, predicate t)
            .Where(fun (_, b) -> b)
            .Select(fun (v, _) -> Some v)
            .FirstOrDefault()

    /// Returns the first element of the sequence, or None otherwise.
    let inline tryHead (source: ^T pseq) : ^T option =
        (toPSeq source).Select(Some).FirstOrDefault()

    /// Returns the first element of the sequence, or None otherwise.
    let inline tryLast (source: ^T pseq) : ^T option =
        Seq.tryLast source

    /// Returns the greatest of all elements of the sequence, compared by using Operators.max.
    let inline tryMax (source: ^T seq) : ^T option =    
        if isNull source || Seq.isEmpty source then None else Some ((toPSeq source).Max())
    
    /// Returns the greatest of all elements of the sequence, compared by using Operators.max on
    /// the function result.
    let inline tryMaxBy (projection : ^T -> ^U when ^U : comparison) (source : seq< ^T>) : ^T option = 
        if isNull source || Seq.isEmpty source then None
        else Some (match (toPSeq source)
                    .Select(fun x -> struct (projection x, x))
                    .Aggregate(fun (struct (minVal, minElem)) (struct (curVal, curElem)) ->
                        if curVal > minVal then (struct (curVal, curElem))
                        else (struct (minVal, minElem))) with struct (_, elem) -> elem)
    
    /// Returns the lowest of all elements of the sequence, compared by using Operators.min.
    let inline tryMin (source: ^T seq) : ^T option =    
        if isNull source || Seq.isEmpty source then None else Some ((toPSeq source).Min())
    
    /// Returns the lowest of all elements of the sequence, compared by using Operators.min on
    /// the function result.
    let inline tryMinBy (projection: ^T -> ^U when ^U : comparison) (source: ^T seq) = 
        if isNull source || Seq.isEmpty source then None
        else Some (match (toPSeq source)
                    .Select(fun x -> struct (projection x, x))
                    .Aggregate(fun (struct (minVal, minElem)) (struct (curVal, curElem)) ->
                        if curVal < minVal then struct (curVal, curElem)
                        else struct (minVal, minElem)) with struct (_, elem) -> elem)

    /// Returns the nth element of the sequence, or None if the element doesn't have 'n' or more members.
    let inline tryNth (n: uint32) source : ^T option =
        (toPSeq source).Skip(int n).Select(Some).FirstOrDefault()

    /// Applies the given function to successive elements, returning the first value where the
    /// function returns a Some value.
    let inline tryPick (chooser: ^T -> ^U option) (source: ^T seq) : ^U option =
        (toPSeq source)
            .Select(chooser)
            .Where(Option.isSome)
            .FirstOrDefault()

    /// Returns a new collection containing only the elements of the collection for which the
    /// given predicate returns true. A synonym for PSeq.filter.
    let inline where (predicate: ^T -> bool) source : ^T pseq = filter predicate source

    /// Combines the two sequences into a list of pairs. The two sequences need not have
    /// equal lengths: when one sequence is exhausted any remaining elements in the other sequence are ignored.
    let inline zip (source1: ^T seq) (source2: ^U seq) : (^T * ^U) pseq =
        (toPSeq source1).Zip(toPSeq source2, fun a b -> a, b)    